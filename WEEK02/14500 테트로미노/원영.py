"""
모든 모양의 경우의 수 19가지(5가지 모양의 회전 대칭)
500 * 500 * 19 = 4,750,000번
완전탐색으로 풀만함

- 풀이 아이디어
완전탐색
1. 테트리스 모양을 정의하여 판을 옮기며 모든 값을 찾는다.

- 하나하나 모양을 배열에 넣는 것이 매우 귀찮고 실수가 나면 틀린 부분을 찾는데 시간이 오래걸림
- 다른 좋은 풀이를 고민해봐야할듯
"""
import sys
input = sys.stdin.readline

def sol():
  n, m = map(int, input().split())
  board = [list(map(int, input().split()))for _ in range(n)]

  tetromino = [[(0,0),(0,1),(1,0),(1,1)],
    [(0,0),(0,1),(0,2),(0,3)], [(0,0),(1,0),(2,0),(3,0)],
    [(0,1),(1,1),(1,0),(2,0)], [(0,0), (0,1),(1,1),(1,2)],[(1,0), (1,1),(0,1),(0,2)], [(0,0),(1,0),(1,1),(2,1)],
    [(0,1), (1,0),(1,1),(1,2)],[(0,1),(1,0),(1,1),(2,1)], [(0,0),(1,0),(2,0),(1,1)], [(0,0),(0,1), (0,2),(1,1)],
    [(0,0), (1,0),(2,0),(2,1)], [(1,0),(1,1),(1,2),(0,2)], [(0,0),(0,1),(1,1),(2,1)], [(0,0),(0,1),(0,2),(1,0)],
    [(0,1),(1,1),(2,1),(2,0)], [(0,0),(1,0),(1,1),(1,2)],[(0,0),(0,1),(1,0),(2,0)], [(0,0),(0,1),(0,2),(1,2)]
    ]

  answer = 0

  for i in range(n):
    for j in range(m):
      for el in tetromino:
        temp = 0
        for x,y in el:
          dx = i + x
          dy = j + y
          
          if 0 <= dx <n and 0<= dy <m:
            temp += board[dx][dy]
          else:
            temp = 0
            break

        answer = max(temp, answer)

  print(answer)
sol()

#ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ천잰디?
# 잘보고 갑니다 모든 모양을 배열에 담아서 돌리셨네요
# 수연) ㅋㅋㅋㅋㅋㅋㅋ 입력값 보고 맘편히 for문 n중으로 쓴 사람 공감하고 갑니다..